#define REMOTEXY_MODE__ESP8266_HARDSERIAL_CLOUD

#include <RemoteXY.h>
#define REMOTEXY_SERIAL Serial
#define REMOTEXY_SERIAL_SPEED 115200
#define REMOTEXY_WIFI_SSID "Henry"
#define REMOTEXY_WIFI_PASSWORD "Henry0530"
#define REMOTEXY_CLOUD_SERVER "cloud.remotexy.com"
#define REMOTEXY_CLOUD_PORT 6376
#define REMOTEXY_CLOUD_TOKEN "63e38f71000775c1d3b3f2c6026f3e2a"

#pragma pack(push, 1)
uint8_t RemoteXY_CONF[] =   // 77 bytes
  { 255,3,0,8,0,70,0,16,31,1,68,17,3,53,27,33,8,36,68,17,
  33,53,27,33,8,36,10,48,23,4,15,15,4,26,31,79,78,0,31,79,
  70,70,0,10,48,8,20,15,15,4,26,31,79,78,0,31,79,70,70,0,
  10,48,39,20,15,15,4,26,31,79,78,0,31,79,70,70,0 };

struct {

    // input variables
  uint8_t forward=0; // =1 if state is ON, else =0 
  uint8_t left=0; // =1 if state is ON, else =0 
  uint8_t right=0; // =1 if state is ON, else =0 

    // output variables
  float left_speed;
  float right_speed;

    // other variable
  uint8_t connect_flag;  // =1 if wire connected, else =0 

} RemoteXY;
#pragma pack(pop)
int Left = 3;//左輪為3腳位
int Right = 5;//右輪為3腳位
int speed_dect2 = A1;//right
float val_2;
int beforeval_2=0;
float rpm_2;
int flag=0;//判斷障礙物旗標 if flag=0 no item , if flag=1 there are item
int tmp[10] = { };//暫存陣列
float min_distance;
unsigned long int count_2=0;
unsigned long int timer=0;
unsigned long pulseWidth;
void setup() 
{
  delay(3000);
  RemoteXY_Init (); 
  pinMode(10, OUTPUT); // Set pin 2 as trigger pin
  digitalWrite(10, LOW); // Set trigger LOW for continuous read
  pinMode(11, INPUT); //   Set pin 3 as monitor pin
  pinMode(Left,OUTPUT);
  pinMode(Right,OUTPUT);
  pinMode(speed_dect2, INPUT);
  analogWrite(Left,0);
  analogWrite(Right,0);
  // TODO you setup code  
}

void loop() 
{ 
  val_2=(analogRead(speed_dect2))*5/1024;//PWM convert
  //left signal convert to digital
  if(val_2>2)
  {
    val_2=1;
  }
  else if(val_2<=2)
  {
    val_2=0;
  }
  if(val_2==1 and beforeval_2==0)//Positive edge trigger
  {
    counter_2();
  }
  beforeval_2=val_2;
  RemoteXY_Handler ();
  if(flag=0)//沒有遇到障礙物
  {
     //forward judge
    if(RemoteXY.forward==1&&RemoteXY.right==0&&RemoteXY.left==0)
    {
      analogWrite(Left,15);
      analogWrite(Right,13);
    }
    else if(RemoteXY.forward==0&&RemoteXY.right==0&&RemoteXY.left==0)
    {
      analogWrite(Left,0);
      analogWrite(Right,0);
    }
    //left judge
    if(RemoteXY.left==1)
    {
      analogWrite(Left,15);
      analogWrite(Right,19);
    }
    //right judge  
    if(RemoteXY.right==1)
    {
      analogWrite(Left,21);
      analogWrite(Right,14);
    }
  }

  else if (flag=1)//遇到障礙物
  {
    turn_left();
    flag=2;
  }
  else if (flag=2)//左轉後
  {
    for(int i=0;i<10;i++)
    {
      Lidar_scan();
      tmp[i]=pulseWidth;
      delay(100);
    }
    for(int i=0;i<10;i++)//找到掃一圈最小的距離
    {
      min_distance=tmp[0];
      if(tmp[i]<min_distance)
      min_distance=tmp[i];
    }
    if(min_distance>=45)
    {
      turn_right();
      flag=0;
    }
    else
    {
      analogWrite(Left,15);
      analogWrite(Right,13);
      if(min_distance<20)
      {
        analogWrite(Left,15);
        analogWrite(Right,15);
      }
    }
  }

  //print speed on phone
  if((millis()-timer)>=500)
  { 
      rpm_2=count_2;
      rpm_2=(rpm_2/24)*60;
      RemoteXY.right_speed=rpm_2;
      timer=millis();
      count_2=0;
  }
  Lidar_scan();
}
void counter_2() 
{
   count_2++;
}
void Lidar_scan()
{
  pulseWidth = pulseIn(11, HIGH); // Count how long the pulse is high in microsecond
  pulseWidth = pulseWidth / 10; // 10usec = 1 cm of distance
  if(pulseWidth<30)
  {
    /*Serial.print(pulseWidth); 
    analogWrite(Left,0);
    analogWrite(Right,0);
    RemoteXY.forward=0;//把按鍵reset
    RemoteXY.left=0;
    RemoteXY.right=0;*/
    flag=1;
  }
}
void turn_left()
{
  for(int i;i<=1000;i++)
  {
    analogWrite(Left,21);
    analogWrite(Right,0);
  }
}
void turn_right()
{
  for(int i;i<=1000;i++)
  {
    analogWrite(Left,0);
    analogWrite(Right,21);
  }
}
